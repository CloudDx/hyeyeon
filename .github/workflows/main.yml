# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에 이 이름이 표시됩니다.
name: CI/CD for On-premise Webservice

# 워크플로우가 시작될 조건을 지정합니다.
on:
  # 'main' 브랜치에 push 이벤트가 발생했을 때 실행됩니다.
  push:
    branches: [ "main" ]

# 워크플로우에서 실행될 작업(job)들을 정의합니다.
jobs:
  # 1. CI: Docker 이미지를 빌드하고 Docker Hub에 푸시하는 작업
  build-and-push:
    # 이 작업이 실행될 가상 환경을 지정합니다. (최신 우분투)
    runs-on: ubuntu-latest
    steps:
      # 1-1. 소스 코드 체크아웃
      # GitHub Repository에 있는 코드를 가상 환경으로 가져옵니다.
      - name: Checkout source code
        uses: actions/checkout@v4

      # 1-2. Docker Hub 로그인
      # GitHub Secrets에 저장된 Docker Hub 계정 정보를 사용하여 로그인합니다.
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 1-3. Docker 이미지 빌드 및 푸시
      # Dockerfile을 사용하여 이미지를 빌드하고, Docker Hub에 푸시합니다.
      # 이미지 태그는 고유성을 위해 Git 커밋 해시(SHA)의 앞 7자리를 사용합니다.
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/onpremise-webservice:${{ github.sha }}

  # 2. CD: 운영 서버에 접속하여 최신 버전으로 배포하는 작업
  deploy:
    # 'build-and-push' 작업이 성공적으로 완료되어야 이 작업이 실행됩니다.
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      # 2-1. AWS 자격 증명 설정
      # GitHub Secrets에 저장된 AWS IAM User의 Access Key를 사용하여 인증합니다.
      # 이 IAM User는 SSM 명령을 실행할 권한이 있어야 합니다.
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 2-2. AWS SSM을 통해 원격 서버에 배포 스크립트 실행
      # SSH 포트를 열지 않고 안전하게 명령을 실행합니다.
      - name: Deploy to server via AWS SSM
        uses: aws-actions/aws-ssm-send-command@v1
        with:
          instance-ids: ${{ secrets.AWS_INSTANCE_ID }}
          working-directory: /home/${{ secrets.SSH_USERNAME }}/onpremise
          command: |
             #!/bin/bash
             # 스크립트 실행 중 오류가 발생하면 즉시 중단합니다.
             set -e
 
             # Git 저장소가 없다면 새로 clone 하고, 있다면 최신 코드를 pull 받습니다.
             if [ ! -d ".git" ]; then
               # working-directory가 이미 onpremise이므로 현재 디렉터리에 clone
               git clone https://github.com/${{ github.repository }} .
             fi
             git pull origin main
 
             # GitHub Secrets에 저장된 .env 파일 내용을 서버에 생성합니다.
             # 'EOF'는 Here Document 문법으로, 여러 줄의 문자열을 파일에 쓸 때 사용합니다.
             cat << EOF > .env
             ${{ secrets.ENV_FILE_CONTENT }}
             EOF
 
             # Docker Compose V2를 수동으로 설치하여 호환성 문제를 해결합니다.
             echo "### Installing Docker Compose V2..."
             DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
             mkdir -p $DOCKER_CONFIG/cli-plugins
             curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
             chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
 
             # SSL 인증서가 없는 경우, 발급을 먼저 시도합니다.
             if [ ! -d "/etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}" ]; then
               echo "### SSL certificate not found. Issuing new certificate..."
               
               # 1. 80포트(default.conf.pre)만을 이용한 임시 Nginx 설치 및 실행
               # 먼저 기존 컨테이너가 있다면 모두 내립니다.
               docker compose down --remove-orphans
               # 임시 설정을 복사합니다.
               cp nginx/default.conf.pre nginx/default.conf
               # Nginx만 임시 설정으로 실행합니다.
               docker compose up -d nginx
 
               # 2. Certbot을 실행하여 인증서를 발급합니다.
               docker run --rm \
                 -v "/etc/letsencrypt:/etc/letsencrypt" \
                 -v "/var/www/certbot:/var/www/certbot" \
                 certbot/certbot certonly --webroot -w /var/www/certbot --force-renewal \
                 --email ${{ secrets.CERTBOT_EMAIL }} -d ${{ secrets.DOMAIN_NAME }} --agree-tos -n
               
               # 3. 임시 Nginx를 내리고, 최종 HTTPS 설정(default.conf)으로 되돌립니다.
               docker compose down
               git checkout HEAD -- nginx/default.conf
             fi
 
             # 4. 최종 설정으로 모든 서비스를 재기동합니다.
             docker compose up -d --build --force-recreate --remove-orphans
 
             # DB 마이그레이션을 실행합니다.
             docker compose exec api flask db upgrade
 
             # 사용하지 않는 오래된 Docker 이미지들을 정리하여 서버 용량을 확보합니다.
             docker image prune -f